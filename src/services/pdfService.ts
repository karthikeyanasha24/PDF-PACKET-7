import { PDFDocument, rgb, StandardFonts } from 'pdf-lib'
import type { ProjectFormData, SelectedDocument } from '@/types'

export class PDFService {
  /**
   * Fetch PDF as ArrayBuffer from URL
   */
  private async fetchPDF(url: string): Promise<ArrayBuffer> {
    try {
      const response = await fetch(url)
      if (!response.ok) {
        throw new Error(`Failed to fetch PDF: ${response.statusText}`)
      }
      return await response.arrayBuffer()
    } catch (error) {
      console.error('Error fetching PDF:', error)
      throw new Error(`Could not load PDF from ${url}`)
    }
  }

  /**
   * Create a cover page with project information
   */
  private async createCoverPage(formData: ProjectFormData): Promise<PDFDocument> {
    const pdfDoc = await PDFDocument.create()
    const page = pdfDoc.addPage([612, 792]) // Standard letter size
    
    // Load fonts
    const titleFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold)
    const bodyFont = await pdfDoc.embedFont(StandardFonts.Helvetica)
    
    const { height } = page.getSize()
    
    // Title
    page.drawText('MAXTERRA® Documentation Packet', {
      x: 50,
      y: height - 100,
      size: 24,
      font: titleFont,
      color: rgb(0.1, 0.4, 0.8),
    })
    
    // Project Information
    const projectInfo = [
      `Submitted To: ${formData.submittedTo}`,
      `Project Name: ${formData.projectName}`,
      `Project Number: ${formData.projectNumber || 'N/A'}`,
      `Prepared By: ${formData.preparedBy}`,
      `Email: ${formData.email}`,
      `Phone: ${formData.phone || 'N/A'}`,
      `Date: ${new Date(formData.date).toLocaleDateString()}`,
      `Status: ${formData.status}`,
      `Product: ${formData.product}`,
    ]
    
    let yPosition = height - 180
    projectInfo.forEach((info) => {
      page.drawText(info, {
        x: 50,
        y: yPosition,
        size: 12,
        font: bodyFont,
        color: rgb(0.2, 0.2, 0.2),
      })
      yPosition -= 25
    })
    
    // Footer
    page.drawText('Generated by MAXTERRA® PDF Packet Builder', {
      x: 50,
      y: 50,
      size: 10,
      font: bodyFont,
      color: rgb(0.5, 0.5, 0.5),
    })
    
    return pdfDoc
  }

  /**
   * Create a section divider page
   */
  private async createDividerPage(documentName: string, pageNumber: number): Promise<PDFDocument> {
    const pdfDoc = await PDFDocument.create()
    const page = pdfDoc.addPage([612, 792])
    
    const titleFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold)
    const bodyFont = await pdfDoc.embedFont(StandardFonts.Helvetica)
    
    const { width, height } = page.getSize()
    
    // Section title
    page.drawText('SECTION', {
      x: 50,
      y: height - 150,
      size: 16,
      font: bodyFont,
      color: rgb(0.5, 0.5, 0.5),
    })
    
    page.drawText(documentName, {
      x: 50,
      y: height - 200,
      size: 20,
      font: titleFont,
      color: rgb(0.1, 0.4, 0.8),
    })
    
    // Page number
    page.drawText(`Page ${pageNumber}`, {
      x: width - 100,
      y: 50,
      size: 10,
      font: bodyFont,
      color: rgb(0.5, 0.5, 0.5),
    })
    
    return pdfDoc
  }

  /**
   * Create an error page when a PDF cannot be loaded
   */
  private async createErrorPage(documentName: string, errorMessage: string, pageNumber: number): Promise<PDFDocument> {
    const pdfDoc = await PDFDocument.create()
    const page = pdfDoc.addPage([612, 792])
    
    const titleFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold)
    const bodyFont = await pdfDoc.embedFont(StandardFonts.Helvetica)
    
    const { width, height } = page.getSize()
    
    // Error indicator
    page.drawText('! DOCUMENT ERROR', {
      x: 50,
      y: height - 150,
      size: 16,
      font: titleFont,
      color: rgb(0.8, 0.2, 0.2),
    })
    
    // Document name - clean for ASCII encoding
    const cleanDocumentName = documentName.replace(/[^\x20-\x7E]/g, '?')
    page.drawText(cleanDocumentName, {
      x: 50,
      y: height - 200,
      size: 18,
      font: titleFont,
      color: rgb(0.2, 0.2, 0.2),
    })
    
    // Error message - clean for ASCII encoding
    const cleanErrorMessage = errorMessage.replace(/[^\x20-\x7E]/g, '?')
    const maxWidth = width - 100
    const words = cleanErrorMessage.split(' ')
    let line = ''
    let yPosition = height - 250
    
    words.forEach((word) => {
      const testLine = line + word + ' '
      const textWidth = bodyFont.widthOfTextAtSize(testLine, 12)
      
      if (textWidth > maxWidth && line !== '') {
        page.drawText(line.trim(), {
          x: 50,
          y: yPosition,
          size: 12,
          font: bodyFont,
          color: rgb(0.4, 0.4, 0.4),
        })
        line = word + ' '
        yPosition -= 20
      } else {
        line = testLine
      }
    })
    
    // Draw remaining text
    if (line.trim()) {
      page.drawText(line.trim(), {
        x: 50,
        y: yPosition,
        size: 12,
        font: bodyFont,
        color: rgb(0.4, 0.4, 0.4),
      })
    }
    
    // Suggestion
    page.drawText('Please contact support or try re-uploading this document.', {
      x: 50,
      y: yPosition - 40,
      size: 10,
      font: bodyFont,
      color: rgb(0.6, 0.6, 0.6),
    })
    
    // Page number
    page.drawText(`Page ${pageNumber}`, {
      x: width - 100,
      y: 50,
      size: 10,
      font: bodyFont,
      color: rgb(0.5, 0.5, 0.5),
    })
    
    return pdfDoc
  }

  /**
   * Generate complete PDF packet
   */
  async generatePacket(
    formData: ProjectFormData,
    selectedDocuments: SelectedDocument[]
  ): Promise<Uint8Array> {
    try {
      // Create final PDF document
      const finalPdf = await PDFDocument.create()
      let currentPageNumber = 1

      // Add cover page
      const coverPdf = await this.createCoverPage(formData)
      const coverPages = await finalPdf.copyPages(coverPdf, coverPdf.getPageIndices())
      coverPages.forEach((page) => finalPdf.addPage(page))
      currentPageNumber++

      // Sort documents by order
      const sortedDocs = selectedDocuments
        .filter(doc => doc.selected)
        .sort((a, b) => a.order - b.order)

      // Process each selected document
      for (const selectedDoc of sortedDocs) {
        try {
          // Add divider page
          const dividerPdf = await this.createDividerPage(
            selectedDoc.document.name,
            currentPageNumber
          )
          const dividerPages = await finalPdf.copyPages(dividerPdf, dividerPdf.getPageIndices())
          dividerPages.forEach((page) => finalPdf.addPage(page))
          currentPageNumber++

          // Fetch and add the actual PDF document
          try {
            const pdfBytes = await this.fetchPDF(selectedDoc.document.url)
            
            // Try to load PDF with multiple fallback strategies
            let pdf: PDFDocument | null = null
            let loadError: Error | null = null
            
            // Strategy 1: Normal load
            try {
              pdf = await PDFDocument.load(pdfBytes)
            } catch (error1) {
              loadError = error1 as Error
              
              // Strategy 2: Ignore encryption
              try {
                console.warn(`PDF ${selectedDoc.document.name} failed normal load, trying with ignoreEncryption...`)
                pdf = await PDFDocument.load(pdfBytes, { ignoreEncryption: true })
                loadError = null
              } catch (error2) {
                // Strategy 3: Try with updateMetadata false
                try {
                  console.warn(`PDF ${selectedDoc.document.name} failed with ignoreEncryption, trying with updateMetadata: false...`)
                  pdf = await PDFDocument.load(pdfBytes, { 
                    ignoreEncryption: true,
                    updateMetadata: false 
                  })
                  loadError = null
                } catch (error3) {
                  loadError = error3 as Error
                }
              }
            }
            
            if (pdf && !loadError) {
              // Successfully loaded PDF
              try {
                const pages = await finalPdf.copyPages(pdf, pdf.getPageIndices())
                pages.forEach((page) => {
                  finalPdf.addPage(page)
                  currentPageNumber++
                })
              } catch (copyError) {
                throw new Error(`Failed to copy pages: ${copyError instanceof Error ? copyError.message : 'Unknown error'}`)
              }
            } else {
              // All loading strategies failed
              throw loadError || new Error('Unable to load PDF document')
            }
            
          } catch (pdfError) {
            console.error(`Failed to process PDF ${selectedDoc.document.name}:`, pdfError)
            
            // Create an error page instead of failing completely
            try {
              const errorMessage = pdfError instanceof Error ? pdfError.message : 'Unknown error occurred'
              const cleanErrorMessage = errorMessage.replace(/[^\x20-\x7E]/g, '?') // Replace non-ASCII chars
              
              const errorPdf = await this.createErrorPage(
                selectedDoc.document.name,
                `Unable to load PDF: ${cleanErrorMessage}`,
                currentPageNumber
              )
              const errorPages = await finalPdf.copyPages(errorPdf, errorPdf.getPageIndices())
              errorPages.forEach((page) => finalPdf.addPage(page))
              currentPageNumber++
            } catch (errorPageError) {
              console.error(`Failed to create error page for ${selectedDoc.document.name}:`, errorPageError)
              // Skip this document entirely if we can't even create an error page
            }
          }
        } catch (error) {
          console.error(`Error processing document ${selectedDoc.document.name}:`, error)
          // Continue with other documents even if one fails
        }
      }

      // Ensure we have at least the cover page
      if (finalPdf.getPageCount() === 0) {
        throw new Error('No pages were successfully added to the PDF packet')
      }

      // Generate final PDF bytes
      const pdfBytes = await finalPdf.save()
      
      // Validate the generated PDF
      if (pdfBytes.length === 0) {
        throw new Error('Generated PDF is empty')
      }
      
      console.log(`Successfully generated PDF packet with ${finalPdf.getPageCount()} pages (${pdfBytes.length} bytes)`)
      return pdfBytes
    } catch (error) {
      console.error('Error generating PDF packet:', error)
      throw new Error('Failed to generate PDF packet. Please check your document selections and try again.')
    }
  }

  /**
   * Download PDF file
   */
  downloadPDF(pdfBytes: Uint8Array, filename: string): void {
    const arrayBuffer = new ArrayBuffer(pdfBytes.length)
    const view = new Uint8Array(arrayBuffer)
    view.set(pdfBytes)
    const blob = new Blob([arrayBuffer], { type: 'application/pdf' })
    const url = URL.createObjectURL(blob)
    
    const link = document.createElement('a')
    link.href = url
    link.download = filename
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    
    // Clean up
    URL.revokeObjectURL(url)
  }

  /**
   * Preview PDF in new tab
   */
  previewPDF(pdfBytes: Uint8Array): void {
    const arrayBuffer = new ArrayBuffer(pdfBytes.length)
    const view = new Uint8Array(arrayBuffer)
    view.set(pdfBytes)
    const blob = new Blob([arrayBuffer], { type: 'application/pdf' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank')
  }
}

// Export singleton instance
export const pdfService = new PDFService()
